/* 
** NetXMS multiplatform core agent
** Copyright (C) 2003-2011 Victor Kirhenshtein
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU General Public License as published by
** the Free Software Foundation; either version 2 of the License, or
** (at your option) any later version.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
**
** File: nxagentd.cpp
**
**/

#include "nxagentd.h"
#include <nxdbapi.h>

#if defined(_WIN32)
#include <conio.h>
#include <locale.h>
#elif defined(_NETWARE)
#include <screen.h>
#include <library.h>
#else
#include <signal.h>
#include <sys/wait.h>
#endif

#if HAVE_SYS_UTSNAME_H
#include <sys/utsname.h>
#endif

#if HAVE_SYS_SYSCTL_H
#include <sys/sysctl.h>
#endif


//
// Externals
//

THREAD_RESULT THREAD_CALL ListenerThread(void *);
THREAD_RESULT THREAD_CALL SessionWatchdog(void *);
THREAD_RESULT THREAD_CALL TrapSender(void *);
THREAD_RESULT THREAD_CALL MasterAgentListener(void *arg);

void ShutdownTrapSender();

void StartWatchdog();
void StopWatchdog();
int WatchdogMain(DWORD pid);

void InitSessionList();

BOOL PushData(const TCHAR *parameter, const TCHAR *value);

#if !defined(_WIN32) && !defined(_NETWARE)
void InitStaticSubagents();
#endif

#ifdef _WIN32
extern TCHAR g_windowsServiceName[];
extern TCHAR g_windowsServiceDisplayName[];
#endif


//
// Messages generated by mc.pl (for UNIX version only)
//

#ifndef _WIN32
extern unsigned int g_dwNumMessages;
extern const TCHAR *g_szMessages[];
#endif


//
// Valid options for getopt()
//

#if defined(_WIN32)
#define VALID_OPTIONS   "c:CdD:e:EfhHiIM:n:N:P:r:RsSUvX:W:Z:"
#elif defined(_NETWARE)
#define VALID_OPTIONS   "c:CD:fhM:P:r:vZ:"
#else
#define VALID_OPTIONS   "c:CdD:fhM:p:P:r:vX:W:Z:"
#endif


//
// Actions
//

#define ACTION_NONE                    0
#define ACTION_RUN_AGENT               1
#define ACTION_INSTALL_SERVICE         2
#define ACTION_REMOVE_SERVICE          3
#define ACTION_START_SERVICE           4
#define ACTION_STOP_SERVICE            5
#define ACTION_CHECK_CONFIG            6
#define ACTION_INSTALL_EVENT_SOURCE    7
#define ACTION_REMOVE_EVENT_SOURCE     8
#define ACTION_CREATE_CONFIG           9
#define ACTION_HELP							10
#define ACTION_RUN_WATCHDOG            11


//
// Global variables
//

DWORD g_dwFlags = AF_ENABLE_ACTIONS | AF_ENABLE_AUTOLOAD;
TCHAR g_szLogFile[MAX_PATH] = AGENT_DEFAULT_LOG;
TCHAR g_szSharedSecret[MAX_SECRET_LENGTH] = _T("admin");
TCHAR g_szConfigFile[MAX_PATH] = AGENT_DEFAULT_CONFIG;
TCHAR g_szFileStore[MAX_PATH] = AGENT_DEFAULT_FILE_STORE;
TCHAR g_szDataDirectory[MAX_PATH] = AGENT_DEFAULT_DATA_DIR;
TCHAR g_szPlatformSuffix[MAX_PSUFFIX_LENGTH] = _T("");
TCHAR g_szConfigServer[MAX_DB_STRING] = _T("not_set");
TCHAR g_szRegistrar[MAX_DB_STRING] = _T("not_set");
TCHAR g_szListenAddress[MAX_PATH] = _T("*");
TCHAR g_szConfigIncludeDir[MAX_PATH] = AGENT_DEFAULT_CONFIG_D;
TCHAR g_masterAgent[MAX_PATH] = _T("not_set");
WORD g_wListenPort = AGENT_LISTEN_PORT;
SERVER_INFO g_pServerList[MAX_SERVERS];
DWORD g_dwServerCount = 0;
DWORD g_dwExecTimeout = 2000;     // External process execution timeout in milliseconds
DWORD g_dwSNMPTimeout = 3000;
time_t g_tmAgentStartTime;
DWORD g_dwStartupDelay = 0;
DWORD g_dwMaxSessions = 32;
DWORD g_debugLevel = 0;
Config *g_config;
#ifdef _WIN32
DWORD g_dwIdleTimeout = 60;   // Session idle timeout
#else
DWORD g_dwIdleTimeout = 120;   // Session idle timeout
#endif

#if !defined(_WIN32) && !defined(_NETWARE)
TCHAR g_szPidFile[MAX_PATH] = _T("/var/run/nxagentd.pid");
#endif

#ifdef _WIN32
DWORD (__stdcall *imp_HrLanConnectionNameFromGuidOrPath)(LPWSTR, LPWSTR, LPWSTR, LPDWORD);
#endif   /* _WIN32 */

#ifdef _NETWARE
int g_nThreadCount = 0;
#endif


//
// Static variables
//

static TCHAR *m_pszActionList = NULL;
static TCHAR *m_pszShellActionList = NULL;
static TCHAR *m_pszServerList = NULL;
static TCHAR *m_pszControlServerList = NULL;
static TCHAR *m_pszMasterServerList = NULL;
static TCHAR *m_pszSubagentList = NULL;
static TCHAR *m_pszExtParamList = NULL;
static TCHAR *m_pszShExtParamList = NULL;
static TCHAR *m_pszParamProviderList = NULL;
static TCHAR *m_pszExtSubagentList = NULL;
static DWORD m_dwEnabledCiphers = 0xFFFF;
static THREAD m_thSessionWatchdog = INVALID_THREAD_HANDLE;
static THREAD m_thListener = INVALID_THREAD_HANDLE;
static THREAD m_thTrapSender = INVALID_THREAD_HANDLE;
static THREAD m_thMasterAgentListener = INVALID_THREAD_HANDLE;
static TCHAR m_szProcessToWait[MAX_PATH] = _T("");
static TCHAR m_szDumpDir[MAX_PATH] = _T("C:\\");
static DWORD m_dwMaxLogSize = 16384 * 1024;
static DWORD m_dwLogHistorySize = 4;
static DWORD m_dwLogRotationMode = NXLOG_ROTATION_BY_SIZE;
static TCHAR m_szDailyLogFileSuffix[64] = _T("");
static Config *s_registry = NULL;

#if defined(_WIN32) || defined(_NETWARE)
static CONDITION m_hCondShutdown = INVALID_CONDITION_HANDLE;
#endif

#if !defined(_WIN32) && !defined(_NETWARE)
static pid_t m_pid;
#endif


//
// Configuration file template
//

static NX_CFG_TEMPLATE m_cfgTemplate[] =
{
   { "Action", CT_STRING_LIST, '\n', 0, 0, 0, &m_pszActionList },
   { "ActionShellExec", CT_STRING_LIST, '\n', 0, 0, 0, &m_pszShellActionList },
   { "ControlServers", CT_STRING_LIST, ',', 0, 0, 0, &m_pszControlServerList },
   { "CreateCrashDumps", CT_BOOLEAN, 0, 0, AF_CATCH_EXCEPTIONS, 0, &g_dwFlags },
	{ "DataDirectory", CT_STRING, 0, 0, MAX_PATH, 0, g_szDataDirectory },
   { "DailyLogFileSuffix", CT_STRING, 0, 0, MAX_PATH, 0, m_szDailyLogFileSuffix },
	{ "DebugLevel", CT_LONG, 0, 0, 0, 0, &g_debugLevel },
   { "DumpDirectory", CT_STRING, 0, 0, MAX_PATH, 0, m_szDumpDir },
   { "EnableActions", CT_BOOLEAN, 0, 0, AF_ENABLE_ACTIONS, 0, &g_dwFlags },
   { "EnableArbitraryFileUpload", CT_BOOLEAN, 0, 0, AF_ARBITRARY_FILE_UPLOAD, 0, &g_dwFlags },
   { "EnabledCiphers", CT_LONG, 0, 0, 0, 0, &m_dwEnabledCiphers },
   { "EnableProxy", CT_BOOLEAN, 0, 0, AF_ENABLE_PROXY, 0, &g_dwFlags },
   { "EnableSNMPProxy", CT_BOOLEAN, 0, 0, AF_ENABLE_SNMP_PROXY, 0, &g_dwFlags },
   { "EnableSubagentAutoload", CT_BOOLEAN, 0, 0, AF_ENABLE_AUTOLOAD, 0, &g_dwFlags },
   { "EnableWatchdog", CT_BOOLEAN, 0, 0, AF_ENABLE_WATCHDOG, 0, &g_dwFlags },
   { "ExecTimeout", CT_LONG, 0, 0, 0, 0, &g_dwExecTimeout },
	{ "ExternalMasterAgent", CT_STRING, 0, 0, MAX_PATH, 0, g_masterAgent },
   { "ExternalParameter", CT_STRING_LIST, '\n', 0, 0, 0, &m_pszExtParamList },
   { "ExternalParameterShellExec", CT_STRING_LIST, '\n', 0, 0, 0, &m_pszShExtParamList },
   { "ExternalParametersProvider", CT_STRING_LIST, '\n', 0, 0, 0, &m_pszParamProviderList },
   { "ExternalSubagent", CT_STRING_LIST, '\n', 0, 0, 0, &m_pszExtSubagentList },
   { "FileStore", CT_STRING, 0, 0, MAX_PATH, 0, g_szFileStore },
   { "FullCrashDumps", CT_BOOLEAN, 0, 0, AF_WRITE_FULL_DUMP, 0, &g_dwFlags },
   { "ListenAddress", CT_STRING, 0, 0, MAX_PATH, 0, g_szListenAddress },
   { "ListenPort", CT_WORD, 0, 0, 0, 0, &g_wListenPort },
   { "LogFile", CT_STRING, 0, 0, MAX_PATH, 0, g_szLogFile },
   { "LogHistorySize", CT_LONG, 0, 0, 0, 0, &m_dwLogHistorySize },
   { "LogRotationMode", CT_LONG, 0, 0, 0, 0, &m_dwLogRotationMode },
   { "LogUnresolvedSymbols", CT_BOOLEAN, 0, 0, AF_LOG_UNRESOLVED_SYMBOLS, 0, &g_dwFlags },
   { "MasterServers", CT_STRING_LIST, ',', 0, 0, 0, &m_pszMasterServerList },
   { "MaxLogSize", CT_LONG, 0, 0, 0, 0, &m_dwMaxLogSize },
   { "MaxSessions", CT_LONG, 0, 0, 0, 0, &g_dwMaxSessions },
   { "PlatformSuffix", CT_STRING, 0, 0, MAX_PSUFFIX_LENGTH, 0, g_szPlatformSuffix },
   { "RequireAuthentication", CT_BOOLEAN, 0, 0, AF_REQUIRE_AUTH, 0, &g_dwFlags },
   { "RequireEncryption", CT_BOOLEAN, 0, 0, AF_REQUIRE_ENCRYPTION, 0, &g_dwFlags },
   { "Servers", CT_STRING_LIST, ',', 0, 0, 0, &m_pszServerList },
   { "SessionIdleTimeout", CT_LONG, 0, 0, 0, 0, &g_dwIdleTimeout },
   { "SharedSecret", CT_STRING, 0, 0, MAX_SECRET_LENGTH, 0, g_szSharedSecret },
   { "StartupDelay", CT_LONG, 0, 0, 0, 0, &g_dwStartupDelay },
   { "SubAgent", CT_STRING_LIST, '\n', 0, 0, 0, &m_pszSubagentList },
   { "TimeOut", CT_IGNORE, 0, 0, 0, 0, NULL },
   { "WaitForProcess", CT_STRING, 0, 0, MAX_PATH, 0, m_szProcessToWait },
   { "", CT_END_OF_LIST, 0, 0, 0, 0, NULL }
};


//
// Help text
//

static char m_szHelpText[] =
   "Usage: nxagentd [options]\n"
   "Where valid options are:\n"
   "   -c <file>  : Use configuration file <file> (default " AGENT_DEFAULT_CONFIG ")\n"
   "   -C         : Check configuration file and exit\n"
#ifndef _NETWARE
   "   -d         : Run as daemon/service\n"
#endif
	"   -D <level> : Set debug level (0..9)\n"
#ifdef _WIN32
   "   -e <name>  : Windows event source name\n"
#endif
	"   -f         : Run in foreground\n"
   "   -h         : Display help and exit\n"
#ifdef _WIN32
   "   -H         : Hide agent's window when in standalone mode\n"
	"   -i         : Installed Windows service must be interactive\n"
   "   -I         : Install Windows service\n"
#endif
   "   -M <addr>  : Download config from management server <addr>\n"
#ifdef _WIN32
   "   -n <name>  : Service name\n"
   "   -N <name>  : Service display name\n"
#endif
#if !defined(_WIN32) && !defined(_NETWARE)
   "   -p         : Path to pid file (default: /var/run/nxagentd.pid)\n"
#endif
   "   -P <text>  : Set platform suffix to <text>\n"
   "   -r <addr>  : Register agent on management server <addr>\n"
#ifdef _WIN32
   "   -R         : Remove Windows service\n"
   "   -s         : Start Windows servive\n"
   "   -S         : Stop Windows service\n"
#endif
   "   -v         : Display version and exit\n"
   "\n";


//
// Save registry
//

static void SaveRegistry()
{
	TCHAR regPath[MAX_PATH];
	nx_strncpy(regPath, g_szDataDirectory, MAX_PATH - _tcslen(REGISTRY_FILE_NAME) - 1);
	if (regPath[_tcslen(regPath) - 1] != FS_PATH_SEPARATOR_CHAR)
		_tcscat(regPath, FS_PATH_SEPARATOR);
	_tcscat(regPath, REGISTRY_FILE_NAME);

	String xml = s_registry->createXml();
	FILE *f = _tfopen(regPath, _T("w"));
	if (f != NULL)
	{
		_fputts((const TCHAR *)xml, f);
		fclose(f);
	}
	else
	{
		nxlog_write(MSG_REGISTRY_SAVE_FAILED, NXLOG_ERROR, "ss", regPath, strerror(errno));
	}
}


//
// Open registry
//

Config *OpenRegistry()
{
	s_registry->lock();
	return s_registry;
}


//
// Close registry
//

void CloseRegistry(bool modified)
{
	if (modified)
		SaveRegistry();
	s_registry->unlock();
}


#ifdef _WIN32

//
// Get our own console window handle (an alternative to Microsoft's GetConsoleWindow)
//

static HWND GetConsoleHWND()
{
	HWND hWnd;
	DWORD wpid, cpid;

   cpid = GetCurrentProcessId();
   while(1)
   {
	   hWnd = FindWindowEx(NULL, NULL, _T("ConsoleWindowClass"), NULL);
      if (hWnd == NULL)
         break;
	   
      GetWindowThreadProcessId(hWnd, &wpid);
	   if (cpid == wpid)
         break;
   }

	return hWnd;
}


//
// Get proc address and write log file
//

static FARPROC GetProcAddressAndLog(HMODULE hModule, LPCSTR procName)
{
   FARPROC ptr;

   ptr = GetProcAddress(hModule, procName);
   if ((ptr == NULL) && (g_dwFlags & AF_LOG_UNRESOLVED_SYMBOLS))
      nxlog_write(MSG_NO_FUNCTION, EVENTLOG_WARNING_TYPE, "s", procName);
   return ptr;
}


//
// Import symbols
//

static void ImportSymbols()
{
   HMODULE hModule;

   // NETMAN.DLL
   hModule = LoadLibrary(_T("NETMAN.DLL"));
   if (hModule != NULL)
   {
      imp_HrLanConnectionNameFromGuidOrPath = 
         (DWORD (__stdcall *)(LPWSTR, LPWSTR, LPWSTR, LPDWORD))GetProcAddressAndLog(hModule,
            "HrLanConnectionNameFromGuidOrPath");
   }
   else
   {
      nxlog_write(MSG_NO_DLL, EVENTLOG_WARNING_TYPE, "s", "NETMAN.DLL");
   }
}


//
// Shutdown thread (created by H_RestartAgent)
//

static THREAD_RESULT THREAD_CALL ShutdownThread(void *pArg)
{
	DebugPrintf(INVALID_INDEX, 1, _T("Shutdown thread started"));
   Shutdown();
   ExitProcess(0);
   return THREAD_OK; // Never reached
}

#endif   /* _WIN32 */


//
// Restart agent
//

static LONG H_RestartAgent(const TCHAR *action, StringList *args, const TCHAR *data)
{
	DebugPrintf(INVALID_INDEX, 1, _T("H_RestartAgent() called"));

#ifdef _NETWARE
   return ERR_NOT_IMPLEMENTED;
#else
   TCHAR szCmdLine[4096], szPlatformSuffixOption[MAX_PSUFFIX_LENGTH + 16];
#ifdef _WIN32
   TCHAR szExecName[MAX_PATH];
   DWORD dwResult;
   STARTUPINFO si;
   PROCESS_INFORMATION pi;

   GetModuleFileName(GetModuleHandle(NULL), szExecName, MAX_PATH);
#else
   TCHAR szExecName[MAX_PATH] = PREFIX _T("/bin/nxagentd");
#endif

	if (g_szPlatformSuffix[0] != 0)
	{
		_sntprintf(szPlatformSuffixOption, MAX_PSUFFIX_LENGTH + 16, _T("-P \"%s\" "), g_szPlatformSuffix);
	}
	else
	{
		szPlatformSuffixOption[0] = 0;
	}

#ifdef _WIN32
   _sntprintf(szCmdLine, 4096, _T("\"%s\" -c \"%s\" -n \"%s\" -e \"%s\" %s%s%s%s%s-D %d %s-X %u"), szExecName,
              g_szConfigFile, g_windowsServiceName, g_windowsEventSourceName,
				  (g_dwFlags & AF_DAEMON) ? _T("-d ") : _T(""),
              (g_dwFlags & AF_HIDE_WINDOW) ? _T("-H ") : _T(""),
				  (g_dwFlags & AF_CENTRAL_CONFIG) ? _T("-M ") : _T(""),
				  (g_dwFlags & AF_CENTRAL_CONFIG) ? g_szConfigServer : _T(""),
				  (g_dwFlags & AF_CENTRAL_CONFIG) ? _T(" ") : _T(""),
				  g_debugLevel, szPlatformSuffixOption,
              (g_dwFlags & AF_DAEMON) ? 0 : GetCurrentProcessId());
	DebugPrintf(INVALID_INDEX, 1, _T("Restarting agent with command line '%s'"), szCmdLine);

   // Fill in process startup info structure
   memset(&si, 0, sizeof(STARTUPINFO));
   si.cb = sizeof(STARTUPINFO);

   // Create new process
   if (!CreateProcess(NULL, szCmdLine, NULL, NULL, FALSE, 
                      (g_dwFlags & AF_DAEMON) ? (CREATE_NO_WINDOW | DETACHED_PROCESS) : (CREATE_NEW_CONSOLE),
                      NULL, NULL, &si, &pi))
   {
      nxlog_write(MSG_CREATE_PROCESS_FAILED, EVENTLOG_ERROR_TYPE, "se", szCmdLine, GetLastError());
      dwResult = ERR_EXEC_FAILED;
   }
   else
   {
      // Close all handles
      CloseHandle(pi.hThread);
      CloseHandle(pi.hProcess);
      dwResult = ERR_SUCCESS;
   }
   if ((dwResult == ERR_SUCCESS) && (!(g_dwFlags & AF_DAEMON)))
   {
      if (g_dwFlags & AF_HIDE_WINDOW)
      {
         ConditionSet(m_hCondShutdown);
      }
      else
      {
         ThreadCreate(ShutdownThread, 0, NULL);
      }
   }
   return dwResult;
#else
   _sntprintf(szCmdLine, 4096, _T("\"%s\" -c \"%s\" %s%s%s%s-D %d %s-X %lu"), szExecName,
              g_szConfigFile, (g_dwFlags & AF_DAEMON) ? _T("-d ") : _T(""),
				  (g_dwFlags & AF_CENTRAL_CONFIG) ? _T("-M ") : _T(""),
				  (g_dwFlags & AF_CENTRAL_CONFIG) ? g_szConfigServer : _T(""),
				  (g_dwFlags & AF_CENTRAL_CONFIG) ? _T(" ") : _T(""),
				  (int)g_debugLevel, szPlatformSuffixOption,
              (unsigned long)m_pid);
	DebugPrintf(INVALID_INDEX, 1, _T("Restarting agent with command line '%s'"), szCmdLine);
   return ExecuteCommand(szCmdLine, NULL, NULL);
#endif
#endif  /* _NETWARE */
}


//
// This function writes message from subagent to agent's log
//

static void WriteSubAgentMsg(int logLevel, int debugLevel, const TCHAR *pszMsg)
{
	if (logLevel == EVENTLOG_DEBUG_TYPE)
	{
		if (debugLevel <= (int)g_debugLevel)
			nxlog_write(MSG_DEBUG, EVENTLOG_DEBUG_TYPE, "s", pszMsg);
	}
	else
	{
		nxlog_write(MSG_SUBAGENT_MSG, logLevel, "s", pszMsg);
	}
}


//
// Signal handler for UNIX platforms
//

#if !defined(_WIN32) && !defined(_NETWARE)

static THREAD_RESULT THREAD_CALL SignalHandler(void *pArg)
{
	sigset_t signals;
	int nSignal;

	sigemptyset(&signals);
	sigaddset(&signals, SIGTERM);
	sigaddset(&signals, SIGINT);
	sigaddset(&signals, SIGPIPE);
	sigaddset(&signals, SIGSEGV);
	sigaddset(&signals, SIGHUP);
	sigaddset(&signals, SIGUSR1);
	sigaddset(&signals, SIGUSR2);

	sigprocmask(SIG_BLOCK, &signals, NULL);

	while(1)
	{
		if (sigwait(&signals, &nSignal) == 0)
		{
			switch(nSignal)
			{
				case SIGTERM:
				case SIGINT:
					goto stop_handler;
				case SIGSEGV:
					abort();
					break;
				default:
					break;
			}
		}
		else
		{
			ThreadSleepMs(100);
		}
	}

stop_handler:
	sigprocmask(SIG_UNBLOCK, &signals, NULL);
	return THREAD_OK;
}

#endif


//
// Load subagent for Windows NT or Windows 9x or platform subagent on UNIX
//

#ifdef _WIN32

void LoadWindowsSubagent()
{
   OSVERSIONINFO ver;

   ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
   if (GetVersionEx(&ver))
   {
      switch(ver.dwPlatformId)
      {
         case VER_PLATFORM_WIN32_WINDOWS:    // Windows 9x
            LoadSubAgent("WIN9X.NSM");
            break;
         case VER_PLATFORM_WIN32_NT:   // Windows NT or higher
            LoadSubAgent("WINNT.NSM");
            break;
         default:
            break;
      }
   }
   else
   {
      nxlog_write(MSG_GETVERSION_FAILED, EVENTLOG_WARNING_TYPE, "e", GetLastError());
   }
}

#else

void LoadPlatformSubagent()
{
#if defined(_NETWARE)
   LoadSubAgent("NETWARE.NSM");
#elif HAVE_SYS_UTSNAME_H && !defined(_STATIC_AGENT)
   struct utsname un;
   char szName[MAX_PATH];
   int i;

   if (uname(&un) != -1)
   {
      // Convert system name to lowercase
      for(i = 0; un.sysname[i] != 0; i++)
         un.sysname[i] = tolower(un.sysname[i]);
      if (!strcmp(un.sysname, "hp-ux"))
         strcpy(un.sysname, "hpux");
      snprintf(szName, MAX_PATH, LIBDIR "/libnsm_%s" SHL_SUFFIX, un.sysname);
      LoadSubAgent(szName);
   }
#endif
}

#endif


//
// Send file to server (subagent API)
//

static BOOL SendFileToServer(void *session, DWORD requestId, const TCHAR *file, long offset)
{
	if (session == NULL)
		return FALSE;

	return ((CommSession *)session)->sendFile(requestId, file, offset);
}


//
// Debug callback for DB library
//

static void DBLibraryDebugCallback(int level, const TCHAR *format, va_list args)
{
	if (level <= (int)g_debugLevel)
	{
      TCHAR buffer[4096];

      _vsntprintf(buffer, 4096, format, args);
      nxlog_write(MSG_DEBUG, EVENTLOG_DEBUG_TYPE, "s", buffer);
	}
}


//
// Initialization routine
//

BOOL Initialize()
{
   TCHAR *pItem, *pEnd;
	TCHAR regPath[MAX_PATH];
#ifdef _NETWARE
   char szLoadPath[1024], szSearchPath[1024];
#endif

   // Open log file
	if (!(g_dwFlags & AF_USE_SYSLOG))
	{
		if (!nxlog_set_rotation_policy((int)m_dwLogRotationMode, (int)m_dwMaxLogSize, (int)m_dwLogHistorySize, m_szDailyLogFileSuffix))
			if (!(g_dwFlags & AF_DAEMON))
				_tprintf(_T("WARNING: cannot set log rotation policy; using default values\n"));
	}
   if (!nxlog_open((g_dwFlags & AF_USE_SYSLOG) ? NXAGENTD_SYSLOG_NAME : g_szLogFile,
	                ((g_dwFlags & AF_USE_SYSLOG) ? NXLOG_USE_SYSLOG : 0) |
	                   ((g_dwFlags & AF_DAEMON) ? 0 : NXLOG_PRINT_TO_STDOUT),
	                _T("NXAGENTD.EXE"),
#ifdef _WIN32
	                0, NULL))
#else
	                g_dwNumMessages, g_szMessages))
#endif
	{
		_ftprintf(stderr, _T("FATAL ERROR: Cannot open log file\n"));
		return FALSE;
	}
	nxlog_write(MSG_USE_CONFIG_D, NXLOG_INFO, "s", g_szConfigIncludeDir);
	nxlog_write(MSG_DEBUG_LEVEL, NXLOG_INFO, "d", g_debugLevel);

	if (_tcscmp(g_masterAgent, _T("not_set")))
	{
		g_dwFlags |= AF_SUBAGENT_LOADER;
		DebugPrintf(INVALID_INDEX, 1, _T("Switched to external subagent loader mode, master agent address is %s"), g_masterAgent);
	}

	// Initialize persistent storage
	s_registry = new Config;
	s_registry->setTopLevelTag(_T("registry"));
	nx_strncpy(regPath, g_szDataDirectory, MAX_PATH - _tcslen(REGISTRY_FILE_NAME) - 1);
	if (regPath[_tcslen(regPath) - 1] != FS_PATH_SEPARATOR_CHAR)
		_tcscat(regPath, FS_PATH_SEPARATOR);
	_tcscat(regPath, REGISTRY_FILE_NAME);
	if (!s_registry->loadXmlConfig(regPath, "registry"))
	{
		nxlog_write(MSG_REGISTRY_LOAD_FAILED, NXLOG_ERROR, "s", regPath);
		SaveRegistry();
	}

#ifdef _WIN32
   WSADATA wsaData;
	int wrc = WSAStartup(MAKEWORD(2, 2), &wsaData);
   if (wrc != 0)
   {
      nxlog_write(MSG_WSASTARTUP_FAILED, NXLOG_ERROR, "e", wrc);
      return FALSE;
   }
#endif

   // Add NLM load path to search list
#ifdef _NETWARE
   if (getnlmloadpath(szLoadPath) != NULL)
   {
      int i, nIsDOS;
      BOOL bExist = FALSE;

      for(i = 0; ; i++)
      {
         if (GetSearchPathElement(i, &nIsDOS, szSearchPath) != 0)
            break;
         if (strlen(szLoadPath) == szSearchPath[0])
            if (!strncasecmp(&szSearchPath[1], szLoadPath, szSearchPath[0]))
            {
               bExist = TRUE;
               break;
            }
      }
      if (!bExist)
         InsertSearchPath(getnetwarelogger(), 0, szLoadPath);
   }
#endif

   // Initialize API for subagents
   InitSubAgentAPI(WriteSubAgentMsg, SendTrap, SendTrap, SendFileToServer, PushData);
   DebugPrintf(INVALID_INDEX, 1, _T("Subagent API initialized"));

   // Initialize cryptografy
   if (!InitCryptoLib(m_dwEnabledCiphers))
   {
      nxlog_write(MSG_INIT_CRYPTO_FAILED, EVENTLOG_ERROR_TYPE, "e", WSAGetLastError());
      return FALSE;
   }

	if (!(g_dwFlags & AF_SUBAGENT_LOADER))
	{
	   InitSessionList();

		// Initialize built-in parameters
		if (!InitParameterList())
			return FALSE;

#ifdef _WIN32
		// Dynamically import functions that may not be presented in all Windows versions
		ImportSymbols();
#endif

		// Parse server list
		if (m_pszServerList != NULL)
		{
			for(pItem = pEnd = m_pszServerList; pEnd != NULL && *pItem != 0; pItem = pEnd + 1)
			{
				pEnd = strchr(pItem, ',');
				if (pEnd != NULL)
					*pEnd = 0;
				StrStrip(pItem);
				g_pServerList[g_dwServerCount].dwIpAddr = ResolveHostName(pItem);
				if ((g_pServerList[g_dwServerCount].dwIpAddr == INADDR_NONE) ||
					 (g_pServerList[g_dwServerCount].dwIpAddr == INADDR_ANY))
				{
					if (!(g_dwFlags & AF_DAEMON))
						printf("Invalid server address '%s'\n", pItem);
				}
				else
				{
					g_pServerList[g_dwServerCount].bMasterServer = FALSE;
					g_pServerList[g_dwServerCount].bControlServer = FALSE;
					g_dwServerCount++;
				}
			}
			free(m_pszServerList);
		}

		// Parse master server list
		if (m_pszMasterServerList != NULL)
		{
			DWORD i, dwAddr;

			for(pItem = pEnd = m_pszMasterServerList; pEnd != NULL && *pItem != 0; pItem = pEnd + 1)
			{
				pEnd = strchr(pItem, ',');
				if (pEnd != NULL)
					*pEnd = 0;
				StrStrip(pItem);

				dwAddr = ResolveHostName(pItem);
				if ((dwAddr == INADDR_NONE) ||
					 (dwAddr == INADDR_ANY))
				{
					if (!(g_dwFlags & AF_DAEMON))
						_tprintf(_T("Invalid server address '%s'\n"), pItem);
				}
				else
				{
					for(i = 0; i < g_dwServerCount; i++)
						if (g_pServerList[i].dwIpAddr == dwAddr)
							break;

					if (i == g_dwServerCount)
					{
						g_pServerList[g_dwServerCount].dwIpAddr = dwAddr;
						g_pServerList[g_dwServerCount].bMasterServer = TRUE;
						g_pServerList[g_dwServerCount].bControlServer = TRUE;
						g_dwServerCount++;
					}
					else
					{
						g_pServerList[i].bMasterServer = TRUE;
						g_pServerList[i].bControlServer = TRUE;
					}
				}
			}
			free(m_pszMasterServerList);
		}

		// Parse control server list
		if (m_pszControlServerList != NULL)
		{
			DWORD i, dwAddr;

			for(pItem = pEnd = m_pszControlServerList; pEnd != NULL && *pItem != 0; pItem = pEnd + 1)
			{
				pEnd = strchr(pItem, ',');
				if (pEnd != NULL)
					*pEnd = 0;
				StrStrip(pItem);

				dwAddr = ResolveHostName(pItem);
				if ((dwAddr == INADDR_NONE) ||
					 (dwAddr == INADDR_ANY))
				{
					if (!(g_dwFlags & AF_DAEMON))
						_tprintf(_T("Invalid server address '%s'\n"), pItem);
				}
				else
				{
					for(i = 0; i < g_dwServerCount; i++)
						if (g_pServerList[i].dwIpAddr == dwAddr)
							break;

					if (i == g_dwServerCount)
					{
						g_pServerList[g_dwServerCount].dwIpAddr = dwAddr;
						g_pServerList[g_dwServerCount].bMasterServer = FALSE;
						g_pServerList[g_dwServerCount].bControlServer = TRUE;
						g_dwServerCount++;
					}
					else
					{
						g_pServerList[i].bControlServer = TRUE;
					}
				}
			}
			free(m_pszControlServerList);
		}

		// Add built-in actions
		AddAction("Agent.Restart", AGENT_ACTION_SUBAGENT, NULL, H_RestartAgent, "CORE", "Restart agent");

	   // Load platform subagents
#if !defined(_WIN32) && !defined(_NETWARE)
		InitStaticSubagents();
#endif
		if (g_dwFlags & AF_ENABLE_AUTOLOAD)
		{
#ifdef _WIN32
	      LoadWindowsSubagent();
#else
		   LoadPlatformSubagent();
#endif
		}
	}

	// Wait for external process if requested
	if (m_szProcessToWait[0] != 0)
	{
	   DebugPrintf(INVALID_INDEX, 1, "Waiting for process %s", m_szProcessToWait);
		if (!WaitForProcess(m_szProcessToWait))
	      nxlog_write(MSG_WAITFORPROCESS_FAILED, EVENTLOG_ERROR_TYPE, "s", m_szProcessToWait);
	}

	DBSetDebugPrintCallback(DBLibraryDebugCallback);
	DBInit(MSG_DB_LIBRARY, MSG_SQL_ERROR);

	// Load other subagents
   if (m_pszSubagentList != NULL)
   {
      for(pItem = pEnd = m_pszSubagentList; pEnd != NULL && *pItem != 0; pItem = pEnd + 1)
      {
         pEnd = strchr(pItem, '\n');
         if (pEnd != NULL)
            *pEnd = 0;
         StrStrip(pItem);
         LoadSubAgent(pItem);
      }
      free(m_pszSubagentList);
   }

   // Parse action list
   if (m_pszActionList != NULL)
   {
      for(pItem = pEnd = m_pszActionList; pEnd != NULL && *pItem != 0; pItem = pEnd + 1)
      {
         pEnd = strchr(pItem, '\n');
         if (pEnd != NULL)
            *pEnd = 0;
         StrStrip(pItem);
         if (!AddActionFromConfig(pItem, FALSE))
            nxlog_write(MSG_ADD_ACTION_FAILED, EVENTLOG_WARNING_TYPE, "s", pItem);
      }
      free(m_pszActionList);
   }
   if (m_pszShellActionList != NULL)
   {
      for(pItem = pEnd = m_pszShellActionList; pEnd != NULL && *pItem != 0; pItem = pEnd + 1)
      {
         pEnd = _tcschr(pItem, _T('\n'));

         if (pEnd != NULL)
            *pEnd = 0;
         StrStrip(pItem);
         if (!AddActionFromConfig(pItem, TRUE))
            nxlog_write(MSG_ADD_ACTION_FAILED, EVENTLOG_WARNING_TYPE, "s", pItem);
      }
      free(m_pszShellActionList);
   }

   // Parse external parameters list
   if (m_pszExtParamList != NULL)
   {
      for(pItem = pEnd = m_pszExtParamList; pEnd != NULL && *pItem != 0; pItem = pEnd + 1)
      {
         pEnd = strchr(pItem, '\n');
         if (pEnd != NULL)
            *pEnd = 0;
         StrStrip(pItem);
         if (!AddExternalParameter(pItem, FALSE))
            nxlog_write(MSG_ADD_EXT_PARAM_FAILED, EVENTLOG_WARNING_TYPE, "s", pItem);
      }
      free(m_pszExtParamList);
   }
   if (m_pszShExtParamList != NULL)
   {
      for(pItem = pEnd = m_pszShExtParamList; pEnd != NULL && *pItem != 0; pItem = pEnd + 1)
      {
         pEnd = strchr(pItem, '\n');
         if (pEnd != NULL)
            *pEnd = 0;
         StrStrip(pItem);
         if (!AddExternalParameter(pItem, TRUE))
            nxlog_write(MSG_ADD_EXT_PARAM_FAILED, EVENTLOG_WARNING_TYPE, "s", pItem);
      }
      free(m_pszShExtParamList);
   }

   // Parse external parameters providers list
   if (m_pszParamProviderList != NULL)
   {
      for(pItem = pEnd = m_pszParamProviderList; pEnd != NULL && *pItem != 0; pItem = pEnd + 1)
      {
         pEnd = strchr(pItem, '\n');
         if (pEnd != NULL)
            *pEnd = 0;
         StrStrip(pItem);
         if (!AddParametersProvider(pItem))
            nxlog_write(MSG_ADD_PARAM_PROVIDER_FAILED, EVENTLOG_WARNING_TYPE, "s", pItem);
      }
      free(m_pszParamProviderList);
   }

   // Parse external subagents list
	if (!(g_dwFlags & AF_SUBAGENT_LOADER) && (m_pszExtSubagentList != NULL))
   {
      for(pItem = pEnd = m_pszExtSubagentList; pEnd != NULL && *pItem != 0; pItem = pEnd + 1)
      {
         pEnd = strchr(pItem, '\n');
         if (pEnd != NULL)
            *pEnd = 0;
         StrStrip(pItem);
         if (!AddExternalSubagent(pItem))
            nxlog_write(MSG_ADD_EXTERNAL_SUBAGENT_FAILED, EVENTLOG_WARNING_TYPE, "s", pItem);
      }
      free(m_pszExtSubagentList);
   }

   ThreadSleep(1);

   // If StartupDelay is greater than zero, then wait
   if (g_dwStartupDelay > 0)
   {
      if (g_dwFlags & AF_DAEMON)
      {
         ThreadSleep(g_dwStartupDelay);
      }
      else
      {
         DWORD i;

         printf("XXXXXX%*s]\rWAIT [", g_dwStartupDelay, " ");
         fflush(stdout);
         for(i = 0; i < g_dwStartupDelay; i++)
         {
            ThreadSleep(1);
            putc('.', stdout);
            fflush(stdout);
         }
         printf("\n");
      }
   }

	StartParamProvidersPoller();

   // Agent start time
   g_tmAgentStartTime = time(NULL);

	if (g_dwFlags & AF_SUBAGENT_LOADER)
	{
		m_thMasterAgentListener = ThreadCreateEx(MasterAgentListener, 0, NULL);
	}
	else
	{
		// Start network listener and session watchdog
		m_thListener = ThreadCreateEx(ListenerThread, 0, NULL);
		m_thSessionWatchdog = ThreadCreateEx(SessionWatchdog, 0, NULL);
		m_thTrapSender = ThreadCreateEx(TrapSender, 0, NULL);
	}

#if defined(_WIN32) || defined(_NETWARE)
   m_hCondShutdown = ConditionCreate(TRUE);
#endif
   ThreadSleep(1);

	// Start watchdog process
	if (!(g_dwFlags & AF_SUBAGENT_LOADER))
	{
		if (g_dwFlags & AF_ENABLE_WATCHDOG)
			StartWatchdog();
	}

	delete g_config;

   return TRUE;
}


//
// Shutdown routine
//

void Shutdown()
{
	DebugPrintf(INVALID_INDEX, 2, _T("Shutdown() called"));
	if (g_dwFlags & AF_ENABLE_WATCHDOG)
		StopWatchdog();

   g_dwFlags |= AF_SHUTDOWN;

	if (g_dwFlags & AF_SUBAGENT_LOADER)
	{
		// TODO: shall we inform master agent listener about shutdown?
		//ThreadJoin(m_thMasterAgentListener);
	}
	else
	{
		ShutdownTrapSender();
		ThreadJoin(m_thSessionWatchdog);
		ThreadJoin(m_thListener);
		ThreadJoin(m_thTrapSender);
	}

   UnloadAllSubAgents();
   nxlog_write(MSG_AGENT_STOPPED, EVENTLOG_INFORMATION_TYPE, NULL);
   nxlog_close();

   // Notify main thread about shutdown
#ifdef _WIN32
   ConditionSet(m_hCondShutdown);
#endif
   
   // Remove PID file
#if !defined(_WIN32) && !defined(_NETWARE)
   remove(g_szPidFile);
#endif
}


//
// Common Main()
//

void Main()
{
   nxlog_write(MSG_AGENT_STARTED, NXLOG_INFO, NULL);

   if (g_dwFlags & AF_DAEMON)
   {
#if defined(_WIN32) || defined(_NETWARE)
      ConditionWait(m_hCondShutdown, INFINITE);
#else
      StartMainLoop(SignalHandler, NULL);
#endif
   }
   else
   {
#if defined(_WIN32)
      if (g_dwFlags & AF_HIDE_WINDOW)
      {
         HWND hWnd;

         hWnd = GetConsoleHWND();
         if (hWnd != NULL)
            ShowWindow(hWnd, SW_HIDE);
         ConditionWait(m_hCondShutdown, INFINITE);
         ThreadSleep(1);
      }
      else
      {
         printf("Agent running. Press ESC to shutdown.\n");
         while(1)
         {
            if (_getch() == 27)
               break;
         }
         printf("Agent shutting down...\n");
         Shutdown();
      }
#elif defined(_NETWARE)
      printf("Agent running. Type UNLOAD NXAGENTD on the system console for shutdown.\n");
      ConditionWait(m_hCondShutdown, INFINITE);
#else
      printf("Agent running. Press Ctrl+C to shutdown.\n");
      StartMainLoop(SignalHandler, NULL);
      printf("\nStopping agent...\n");
#endif
   }
}


//
// Do necessary actions on agent restart
//

static void DoRestartActions(DWORD dwOldPID)
{
#if defined(_WIN32)
   if (dwOldPID == 0)
   {
      // Service
      StopAgentService();
      WaitForService(SERVICE_STOPPED);
      StartAgentService();
      ExitProcess(0);
   }
   else
   {
      HANDLE hProcess;

      hProcess = OpenProcess(SYNCHRONIZE | PROCESS_TERMINATE, FALSE, dwOldPID);
      if (hProcess != NULL)
      {
         if (WaitForSingleObject(hProcess, 60000) == WAIT_TIMEOUT)
         {
            TerminateProcess(hProcess, 0);
         }
         CloseHandle(hProcess);
      }
   }
#elif defined(_NETWARE)
   /* TODO: implement restart for NetWare */
#else
   int i;

   kill(dwOldPID, SIGTERM);
   for(i = 0; i < 30; i++)
   {
      sleep(2);
      if (kill(dwOldPID, SIGCONT) == -1)
         break;
   }
   
   // Kill previous instance of agent if it's still running
   if (i == 30)
      kill(dwOldPID, SIGKILL);
#endif
}


//
// NetWare exit handler
//

#ifdef _NETWARE

static void ExitHandler(int nSig)
{
   printf("\n*** Unloading NetXMS agent ***\n");
   ConditionSet(m_hCondShutdown);
   while(g_nThreadCount > 0)
      pthread_yield();
}

#endif


//
// Create configuration file
//

static int CreateConfig(const TCHAR *pszServer, const TCHAR *pszLogFile, const TCHAR *pszFileStore,
                        const TCHAR *configIncludeDir, int iNumSubAgents, TCHAR **ppszSubAgentList)
{
   FILE *fp;
   time_t currTime;
   int i;

   if (_taccess(g_szConfigFile, 0) == 0)
      return 0;  // File already exist, we shouldn't overwrite it

   fp = _tfopen(g_szConfigFile, _T("w"));
   if (fp != NULL)
   {
      currTime = time(NULL);
      _ftprintf(fp, _T("#\n# NetXMS agent configuration file\n# Created by agent installer at %s#\n\n"),
                _tctime(&currTime));
      _ftprintf(fp, _T("MasterServers = %s\nConfigIncludeDir = %s\nLogFile = %s\nFileStore = %s\n"),
                pszServer, configIncludeDir, pszLogFile, pszFileStore);
      for(i = 0; i < iNumSubAgents; i++)
         _ftprintf(fp, _T("SubAgent = %s\n"), ppszSubAgentList[i]);
      fclose(fp);
   }
   return (fp != NULL) ? 0 : 2;
}


//
// Init config
//

static void InitConfig()
{
	g_config = new Config();
	g_config->setTopLevelTag(_T("config"));
}


//
// Startup
//

int main(int argc, char *argv[])
{
   int ch, iExitCode = 0, iAction = ACTION_RUN_AGENT;
   BOOL bRestart = FALSE;
   DWORD dwOldPID, dwMainPID;
	TCHAR *eptr;
#ifdef _WIN32
   TCHAR szModuleName[MAX_PATH];
   HKEY hKey;
   DWORD dwSize;
#else
   char *pszEnv;
#endif

   InitThreadLibrary();

#ifdef NETXMS_MEMORY_DEBUG
	InitMemoryDebugger();
#endif
   
#ifdef _NETWARE
   g_nThreadCount++;
   setscreenmode(SCR_AUTOCLOSE_ON_EXIT | SCR_COLOR_ATTRS);
#endif

   // Set locale to C. It shouldn't be needed, according to
   // documentation, but I've seen the cases when agent formats
   // floating point numbers by sprintf inserting comma in place
   // of a dot, as set by system's regional settings.
#ifdef _WIN32
   setlocale(LC_ALL, "C");
#endif

   // Check for alternate config file location
#ifdef _WIN32
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("Software\\NetXMS\\Agent"), 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
   {
      dwSize = MAX_PATH * sizeof(TCHAR);
      RegQueryValueEx(hKey, _T("ConfigFile"), NULL, NULL, (BYTE *)g_szConfigFile, &dwSize);
      RegQueryValueEx(hKey, _T("ConfigIncludeDir"), NULL, NULL, (BYTE *)g_szConfigIncludeDir, &dwSize);
      RegCloseKey(hKey);
   }
#else
   pszEnv = _tgetenv(_T("NXAGENTD_CONFIG"));
   if (pszEnv != NULL)
      nx_strncpy(g_szConfigFile, pszEnv, MAX_PATH);

	pszEnv = _tgetenv(_T("NXAGENTD_CONFIG_D"));
   if (pszEnv != NULL)
      nx_strncpy(g_szConfigIncludeDir, pszEnv, MAX_PATH);
#endif

   // Parse command line
	if (argc == 1)
		iAction = ACTION_HELP;
   opterr = 1;
   while((ch = getopt(argc, argv, VALID_OPTIONS)) != -1)
   {
      switch(ch)
      {
         case 'h':   // Display help and exit
            iAction = ACTION_HELP;
            break;
         case 'd':   // Run as daemon
            g_dwFlags |= AF_DAEMON;
            break;
			case 'f':	// Run in foreground
            g_dwFlags &= ~AF_DAEMON;
				break;
         case 'D':   // Turn on debug output
				g_debugLevel = strtoul(optarg, &eptr, 0);
				if ((*eptr != 0) || (g_debugLevel > 9))
				{
					fprintf(stderr, "Invalid debug level: %s\n", optarg);
					iAction = -1;
					iExitCode = 1;
				}
            break;
         case 'c':   // Configuration file
            nx_strncpy(g_szConfigFile, optarg, MAX_PATH);
            break;
#if !defined(_WIN32) && !defined(_NETWARE)
         case 'p':   // PID file
            nx_strncpy(g_szPidFile, optarg, MAX_PATH);
            break;
#endif
         case 'C':   // Configuration check only
            iAction = ACTION_CHECK_CONFIG;
            break;
         case 'v':   // Print version and exit
            printf("NetXMS Core Agent Version " AGENT_VERSION_STRING "\n");
            iAction = ACTION_NONE;
            break;
         case 'M':
            g_dwFlags |= AF_CENTRAL_CONFIG;
            nx_strncpy(g_szConfigServer, optarg, MAX_DB_STRING);
            break;
         case 'r':
            g_dwFlags |= AF_REGISTER;
            nx_strncpy(g_szRegistrar, optarg, MAX_DB_STRING);
            break;
         case 'P':   // Platform suffix
            nx_strncpy(g_szPlatformSuffix, optarg, MAX_PSUFFIX_LENGTH);
            break;
         case 'X':   // Agent is being restarted
            bRestart = TRUE;
            dwOldPID = strtoul(optarg, NULL, 10);
            break;
         case 'W':   // Watchdog process
            iAction = ACTION_RUN_WATCHDOG;
            dwMainPID = strtoul(optarg, NULL, 10);
            break;
         case 'Z':   // Create configuration file
            iAction = ACTION_CREATE_CONFIG;
            nx_strncpy(g_szConfigFile, optarg, MAX_PATH);
            break;
#ifdef _WIN32
         case 'H':   // Hide window
            g_dwFlags |= AF_HIDE_WINDOW;
            break;
         case 'i':
            g_dwFlags |= AF_INTERACTIVE_SERVICE;
            break;
         case 'I':   // Install Windows service
            iAction = ACTION_INSTALL_SERVICE;
            break;
         case 'R':   // Remove Windows service
            iAction = ACTION_REMOVE_SERVICE;
            break;
         case 's':   // Start Windows service
            iAction = ACTION_START_SERVICE;
            break;
         case 'S':   // Stop Windows service
            iAction = ACTION_STOP_SERVICE;
            break;
         case 'E':   // Install Windows event source
            iAction = ACTION_INSTALL_EVENT_SOURCE;
            break;
         case 'U':   // Remove Windows event source
            iAction = ACTION_REMOVE_EVENT_SOURCE;
            break;
         case 'e':   // Event source name
            nx_strncpy(g_windowsEventSourceName, optarg, MAX_PATH);
            break;
         case 'n':   // Service name
            nx_strncpy(g_windowsServiceName, optarg, MAX_PATH);
            break;
         case 'N':   // Service display name
            nx_strncpy(g_windowsServiceDisplayName, optarg, MAX_PATH);
            break;
#endif
         case '?':
            iAction = ACTION_HELP;
            iExitCode = 1;
            break;
         default:
            break;
      }
   }

#if !defined(_WIN32) && !defined(_NETWARE)
	if (!_tcscmp(g_szConfigFile, _T("{search}")))
	{
		if (access(PREFIX "/etc/nxagentd.conf", 4) == 0)
		{
			_tcscpy(g_szConfigFile, PREFIX "/etc/nxagentd.conf");
		}
		else if (access("/usr/etc/nxagentd.conf", 4) == 0)
		{
			_tcscpy(g_szConfigFile, "/usr/etc/nxagentd.conf");
		}
		else
		{
			_tcscpy(g_szConfigFile, "/etc/nxagentd.conf");
		}
	}
	if (!_tcscmp(g_szConfigIncludeDir, _T("{search}")))
	{
		if (access(PREFIX "/etc/nxagentd.conf.d", 4) == 0)
		{
			_tcscpy(g_szConfigIncludeDir, PREFIX "/etc/nxagentd.conf.d");
		}
		else if (access("/usr/etc/nxagentd.conf.d", 4) == 0)
		{
			_tcscpy(g_szConfigIncludeDir, "/usr/etc/nxagentd.conf.d");
		}
		else
		{
			_tcscpy(g_szConfigIncludeDir, "/etc/nxagentd.conf.d");
		}
	}
#endif

   if (bRestart)
      DoRestartActions(dwOldPID);

	InitConfig();

   // Do requested action
   switch(iAction)
   {
      case ACTION_RUN_AGENT:
         // Set default value for session idle timeout based on
         // connect() timeout, if possible
#if HAVE_SYSCTLBYNAME && !defined(_IPSO)
         {
            LONG nVal;
				size_t nSize;

				nSize = sizeof(nVal);
            if (sysctlbyname("net.inet.tcp.keepinit", &nVal, &nSize, NULL, 0) == 0)
            {
               g_dwIdleTimeout = nVal / 1000 + 15;
            }
         }
#endif

         if (g_dwFlags & AF_CENTRAL_CONFIG)
         {
            if (g_debugLevel > 0)
               printf("Downloading configuration from %s...\n", g_szConfigServer);
            if (DownloadConfig(g_szConfigServer))
            {
               if (g_debugLevel > 0)
                  printf("Configuration downloaded successfully\n");
            }
            else
            {
               if (g_debugLevel > 0)
                  printf("Configuration download failed\n");
            }
         }

			if (g_config->loadConfig(g_szConfigFile, _T("agent")))
			{
				const TCHAR *dir = g_config->getValue(_T("/agent/ConfigIncludeDir"));
				if (dir != NULL)
					nx_strncpy(g_szConfigIncludeDir, dir, MAX_PATH);
				g_config->loadConfigDirectory(g_szConfigIncludeDir, _T("agent"));
				if (g_config->parseTemplate(_T("agent"), m_cfgTemplate))
				{
					// Set exception handler
#ifdef _WIN32
					if (g_dwFlags & AF_CATCH_EXCEPTIONS)
						SetExceptionHandler(SEHServiceExceptionHandler, SEHServiceExceptionDataWriter, m_szDumpDir,
												  _T("nxagentd"), MSG_EXCEPTION, g_dwFlags & AF_WRITE_FULL_DUMP, !(g_dwFlags & AF_DAEMON));
					__try {
#endif
					if ((!_tcsicmp(g_szLogFile, _T("{syslog}"))) || 
						 (!_tcsicmp(g_szLogFile, _T("{eventlog}"))))
						g_dwFlags |= AF_USE_SYSLOG;

#ifdef _WIN32
					if (g_dwFlags & AF_DAEMON)
					{
						InitService();
					}
					else
					{
						if (Initialize())
						{
							Main();
						}
						else
						{
							ConsolePrintf(_T("Agent initialization failed\n"));
							nxlog_close();
							iExitCode = 3;
						}
					}
#else    /* _WIN32 */
#ifndef _NETWARE
					if (g_dwFlags & AF_DAEMON)
						if (daemon(0, 0) == -1)
						{
							perror("Unable to setup itself as a daemon");
							iExitCode = 4;
						}
#endif
					if (iExitCode == 0)
            {
#ifndef _NETWARE
						m_pid = getpid();
#endif
						if (Initialize())
						{
#ifdef _NETWARE
							signal(SIGTERM, ExitHandler);
#else
							FILE *fp;

							// Write PID file
							fp = fopen(g_szPidFile, "w");
							if (fp != NULL)
							{
								fprintf(fp, "%d", m_pid);
								fclose(fp);
							}   
#endif
							Main();
							Shutdown();
						}
						else
						{
							ConsolePrintf(_T("Agent initialization failed\n"));
							nxlog_close();
							iExitCode = 3;
						}
	            }
#endif   /* _WIN32 */

#if defined(_WIN32) || defined(_NETWARE)
					if (m_hCondShutdown != INVALID_CONDITION_HANDLE)
						ConditionDestroy(m_hCondShutdown);
#endif
#ifdef _WIN32
					LIBNETXMS_EXCEPTION_HANDLER
#endif
				}
				else
				{
					ConsolePrintf(_T("Error parsing configuration file\n"));
					iExitCode = 2;
				}
         }
         else
         {
            ConsolePrintf(_T("Error loading configuration file\n"));
            iExitCode = 2;
         }
         break;
      case ACTION_CHECK_CONFIG:
			if (!g_config->loadIniConfig(g_szConfigFile, _T("agent")) || !g_config->parseTemplate(_T("agent"), m_cfgTemplate))
         {
            ConsolePrintf(_T("Configuration file check failed\n"));
            iExitCode = 2;
         }
         break;
		case ACTION_RUN_WATCHDOG:
			iExitCode = WatchdogMain(dwMainPID);
			break;
      case ACTION_CREATE_CONFIG:
         iExitCode = CreateConfig(CHECK_NULL(argv[optind]), CHECK_NULL(argv[optind + 1]),
                                  CHECK_NULL(argv[optind + 2]), CHECK_NULL(argv[optind + 3]),
											 argc - optind - 4, &argv[optind + 4]);
         break;
#ifdef _WIN32
      case ACTION_INSTALL_SERVICE:
         GetModuleFileName(GetModuleHandle(NULL), szModuleName, MAX_PATH);
         InstallService(szModuleName, g_szConfigFile);
         break;
      case ACTION_REMOVE_SERVICE:
         RemoveService();
         break;
      case ACTION_INSTALL_EVENT_SOURCE:
         GetModuleFileName(GetModuleHandle(NULL), szModuleName, MAX_PATH);
         InstallEventSource(szModuleName);
         break;
      case ACTION_REMOVE_EVENT_SOURCE:
         RemoveEventSource();
         break;
      case ACTION_START_SERVICE:
         StartAgentService();
         break;
      case ACTION_STOP_SERVICE:
         StopAgentService();
         break;
#endif
		case ACTION_HELP:
         fputs(m_szHelpText, stdout);
			break;
      default:
         break;
   }

#ifdef _NETWARE
   if ((iExitCode != 0) || (iAction == ACTION_NONE) || 
       (iAction == ACTION_CHECK_CONFIG))
      setscreenmode(SCR_NO_MODE);
   g_nThreadCount--;
#endif

   return iExitCode;
}
